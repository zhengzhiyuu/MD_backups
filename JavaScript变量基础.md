---
title: 'JavaScript变量基础'
date: 2017-03-01 22:28:06
tags: JavaScript
categories: [前端,JavaScript]
---
变量作用域 声明提前 作用域链 
<!--more-->
### 变量作用域
变量分为全局变量和局部变量（在函数内部声明的变量为局部变量）
一个变量的作用域（scope）是程序源代码中定义这个变量的区域。
全局变量拥有全局作用域，在JavaScript代码中的任何地方都是有定义的。
然而在函数内声明的变量只在函数体内有定义。它们是局部变量，作用域是局部性的。函数参数也是局部变量，它们只在函数体内有定义。 在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。
### 函数作用域和声明提前
JavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。这意味着变量在声明之前就已经可用，JavaScript的这个特性被称为声明提前。(hoisting)
#### 普通函数
```js
var i=10;   
function a() {   
    alert(i);   
};   
a();   
```
#### 声明提前
```js
var i=10;   
function a() {   
    alert(i);   
    var i = 2;   
};   
a();  
```
等同于
```js
var i = 10;
function a() {
    var i; //声明提前
    alert(i);
    i = 2;
}
```
第一个代码正常输出了变量的值10，而第二个代码输出的却是undefined。
#### 原因：
在变量解析过程中首先查找局部的作用域，然后查找上层作用域。在代码一的函数当中没有定义变量i，于是查找上层作用域（全局作用域），进而进行输出其值。但是在代码二的函数内定义了变量i（无论是在alter之后还是之前定义变量，都认为在此作用域拥有变量i），于是不再向上层的作用域进行查找，直接输出i。但是不幸的是此时的局部变量i并没有赋值，所以输出的是undefined。
### 作用域链
JavaScript是基于词法作用域的语言。全局变量在程序中始终都是有定义的。局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的。
```js
var name="yellow";
function fn(){  
    var name="blok";  
    function a(){  
        var name="red";  
        console.log(name);  
    }  
    function b(){  
        console.log(name);  
    }  
    a();  
    b();  
}  
fn();  
```
当执行a时，将创建函数a的执行环境(调用对象),并将该对象置于链表开头，然后将函数fn的调用对象链接在之后，最后是全局对象。然后从链表开头寻找变量name,
` 作用域链 `是:  a()->fn()->window,因为在a()上就找到了name的值red,所以name是"red"。
但执行b()时，` 作用域链 `是： b()->fn()->window,所以name是"blok"
#### 1. 解释：
每一段js代码（全局代码或函数）都有一个与之关联的作用域链（scope chain）。
这个作用域链是一个对象列表或者链表，这组对象定义了这段代码中“作用域中”的变量。
当js需要查找变量x的值的时候（这个过程称为变量解析（variable resolution）），它会从链的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第一个对象中没有名为x的属性，js会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个，以此类推。如果作用域链上没有任何一个对象含有属性x，那么就认为这段代码的作用域链上不存在x，并最终抛出一个引用错误（ReferenceError）异常。
#### 2. 作用域链举例：
在js最顶层代码中（也就是不包括任何函数定义内的代码），作用域链由一个全局对象组成。
在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。
在一个嵌套的函数体内，作用域上至少有三个对象。
#### 3. 作用域链创建规则：
当定义一个函数时（注意:是定义的时候就开始了），它实际上保存一个作用域链。
当调用这个函数时，它创建一个新的对象来储存它的参数或局部变量，并将这个对象添加保存至那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。
对于嵌套函数来说，情况又有所变化：每次调用外部函数的时候，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都要微妙的差别---在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。